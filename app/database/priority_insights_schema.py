"""
Database schema for Priority Insights and Explore & Act feature.

This module handles the database tables for storing priority insights,
notes, and action recommendations generated by the Explore & Act feature.
"""

from app.database.connection import get_db_connection


def create_priority_insights_tables():
    """
    Create the necessary tables for the Priority Insights feature.
    
    Tables created:
    - priority_insights: Stores Gemini-generated insights for each priority
    - priority_notes: Stores user notes and comments for each priority
    - priority_actions: Stores action recommendations for each priority
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # Priority insights table - stores Gemini-generated insights with Google Search grounding
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS priority_insights (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            priority_id TEXT NOT NULL,  -- Unique identifier for the priority (e.g., "short-term-1", "long-term-2")
            grid_type TEXT NOT NULL,    -- "short-term" or "long-term"
            priority_title TEXT NOT NULL,
            priority_data TEXT NOT NULL, -- JSON string of the original priority data
            insights_content TEXT NOT NULL, -- Gemini-generated insights with Google Search grounding
            search_grounding_data TEXT,     -- JSON string of search results used for grounding
            created_ts TEXT NOT NULL DEFAULT (datetime('now')),
            updated_ts TEXT NOT NULL DEFAULT (datetime('now')),
            user_role TEXT NOT NULL,     -- The role that generated this priority
            is_active INTEGER DEFAULT 1, -- 1 for active, 0 for deleted
            UNIQUE(priority_id, user_role)
        )
    """)
    
    # Priority notes table - stores user notes and comments
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS priority_notes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            priority_id TEXT NOT NULL,
            grid_type TEXT NOT NULL,
            user_role TEXT NOT NULL,
            note_content TEXT NOT NULL,
            created_ts TEXT NOT NULL DEFAULT (datetime('now')),
            updated_ts TEXT NOT NULL DEFAULT (datetime('now')),
            is_active INTEGER DEFAULT 1,
            FOREIGN KEY (priority_id, grid_type, user_role) REFERENCES priority_insights(priority_id, grid_type, user_role)
        )
    """)
    
    # Priority actions table - stores action recommendations
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS priority_actions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            priority_id TEXT NOT NULL,
            grid_type TEXT NOT NULL,
            user_role TEXT NOT NULL,
            action_title TEXT NOT NULL,
            action_description TEXT NOT NULL,
            action_type TEXT DEFAULT 'recommended', -- 'recommended', 'user_added', 'completed'
            priority_level INTEGER DEFAULT 1,      -- 1=high, 2=medium, 3=low
            estimated_effort TEXT,                 -- 'low', 'medium', 'high'
            estimated_impact TEXT,                 -- 'low', 'medium', 'high'
            created_ts TEXT NOT NULL DEFAULT (datetime('now')),
            updated_ts TEXT NOT NULL DEFAULT (datetime('now')),
            is_active INTEGER DEFAULT 1,
            FOREIGN KEY (priority_id, grid_type, user_role) REFERENCES priority_insights(priority_id, grid_type, user_role)
        )
    """)
    
    # Create indexes for better performance
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_priority_insights_priority_id ON priority_insights(priority_id)")
    # Saved priority analyses table - stores complete analysis snapshots
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS saved_priority_analyses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            priority_id TEXT NOT NULL,
            grid_type TEXT NOT NULL,
            priority_title TEXT NOT NULL,
            priority_data TEXT NOT NULL,
            insights_content TEXT,
            actions_data TEXT,
            notes_data TEXT,
            user_role TEXT NOT NULL,
            created_ts TEXT NOT NULL DEFAULT (datetime('now')),
            is_active INTEGER DEFAULT 1,
            UNIQUE(priority_id, grid_type, user_role)
        )
    """)
    
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_priority_insights_user_role ON priority_insights(user_role)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_priority_insights_created_ts ON priority_insights(created_ts)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_priority_notes_priority_id ON priority_notes(priority_id)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_priority_actions_priority_id ON priority_actions(priority_id)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_saved_analyses_user_role ON saved_priority_analyses(user_role)")
    
    conn.commit()
    conn.close()


def get_priority_insights(priority_id, grid_type, user_role):
    """
    Get insights for a specific priority.
    
    Args:
        priority_id (str): The priority identifier
        grid_type (str): The grid type (short-term/long-term)
        user_role (str): The user role
        
    Returns:
        dict: Priority insights data or None if not found
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT * FROM priority_insights 
        WHERE priority_id = ? AND grid_type = ? AND user_role = ? AND is_active = 1
        ORDER BY created_ts DESC LIMIT 1
    """, (priority_id, grid_type, user_role))
    
    row = cursor.fetchone()
    conn.close()
    
    if row:
        return dict(row)
    return None


def save_priority_insights(priority_id, grid_type, priority_title, priority_data, 
                          insights_content, search_grounding_data, user_role):
    """
    Save or update priority insights.
    
    Args:
        priority_id (str): The priority identifier
        grid_type (str): "short-term" or "long-term"
        priority_title (str): The priority title
        priority_data (str): JSON string of priority data
        insights_content (str): Gemini-generated insights
        search_grounding_data (str): JSON string of search grounding data
        user_role (str): The user role
        
    Returns:
        int: The ID of the saved insights record
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # Check if insights already exist
    cursor.execute("""
        SELECT id FROM priority_insights 
        WHERE priority_id = ? AND user_role = ? AND is_active = 1
    """, (priority_id, user_role))
    
    existing = cursor.fetchone()
    
    if existing:
        # Update existing record
        cursor.execute("""
            UPDATE priority_insights 
            SET insights_content = ?, search_grounding_data = ?, updated_ts = datetime('now')
            WHERE id = ?
        """, (insights_content, search_grounding_data, existing['id']))
        insight_id = existing['id']
    else:
        # Insert new record
        cursor.execute("""
            INSERT INTO priority_insights 
            (priority_id, grid_type, priority_title, priority_data, insights_content, 
             search_grounding_data, user_role)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (priority_id, grid_type, priority_title, priority_data, 
              insights_content, search_grounding_data, user_role))
        insight_id = cursor.lastrowid
    
    conn.commit()
    conn.close()
    return insight_id


def get_priority_notes(priority_id, grid_type, user_role):
    """
    Get all notes for a specific priority.
    
    Args:
        priority_id (str): The priority identifier
        grid_type (str): The grid type (short-term/long-term)
        user_role (str): The user role
        
    Returns:
        list: List of note dictionaries
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT * FROM priority_notes 
        WHERE priority_id = ? AND grid_type = ? AND user_role = ? AND is_active = 1
        ORDER BY created_ts DESC
    """, (priority_id, grid_type, user_role))
    
    rows = cursor.fetchall()
    conn.close()
    
    return [dict(row) for row in rows]


def add_priority_note(priority_id, grid_type, user_role, note_content):
    """
    Add a new note to a priority.
    
    Args:
        priority_id (str): The priority identifier
        grid_type (str): The grid type (short-term/long-term)
        user_role (str): The user role
        note_content (str): The note content
        
    Returns:
        int: The ID of the new note
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        INSERT INTO priority_notes (priority_id, grid_type, user_role, note_content)
        VALUES (?, ?, ?, ?)
    """, (priority_id, grid_type, user_role, note_content))
    
    note_id = cursor.lastrowid
    conn.commit()
    conn.close()
    
    return note_id


def delete_priority_note(note_id, user_role):
    """
    Delete a specific note by ID.
    
    Args:
        note_id (int): The ID of the note to delete
        user_role (str): The user role for authorization
        
    Returns:
        bool: True if the note was deleted, False if not found
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        DELETE FROM priority_notes 
        WHERE id = ? AND user_role = ?
    """, (note_id, user_role))
    
    deleted_count = cursor.rowcount
    conn.commit()
    conn.close()
    
    return deleted_count > 0


def delete_priority_insight(insight_id, user_role):
    """
    Delete a specific insight by ID.
    
    Args:
        insight_id (int): The ID of the insight to delete
        user_role (str): The user role for authorization
        
    Returns:
        bool: True if the insight was deleted, False if not found
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        DELETE FROM priority_insights 
        WHERE id = ? AND user_role = ?
    """, (insight_id, user_role))
    
    deleted_count = cursor.rowcount
    conn.commit()
    conn.close()
    
    return deleted_count > 0


def delete_priority_action(action_id, user_role):
    """
    Delete a specific action by ID.
    
    Args:
        action_id (int): The ID of the action to delete
        user_role (str): The user role for authorization
        
    Returns:
        bool: True if the action was deleted, False if not found
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        DELETE FROM priority_actions 
        WHERE id = ? AND user_role = ?
    """, (action_id, user_role))
    
    deleted_count = cursor.rowcount
    conn.commit()
    conn.close()
    
    return deleted_count > 0


def get_priority_actions(priority_id, grid_type, user_role):
    """
    Get all actions for a specific priority.
    
    Args:
        priority_id (str): The priority identifier
        grid_type (str): The grid type (short-term/long-term)
        user_role (str): The user role
        
    Returns:
        list: List of action dictionaries
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT * FROM priority_actions 
        WHERE priority_id = ? AND grid_type = ? AND user_role = ? AND is_active = 1
        ORDER BY priority_level ASC, created_ts DESC
    """, (priority_id, grid_type, user_role))
    
    rows = cursor.fetchall()
    conn.close()
    
    return [dict(row) for row in rows]


def add_priority_action(priority_id, grid_type, user_role, action_title, action_description, 
                       action_type='recommended', priority_level=1, 
                       estimated_effort=None, estimated_impact=None):
    """
    Add a new action to a priority.
    
    Args:
        priority_id (str): The priority identifier
        grid_type (str): The grid type (short-term/long-term)
        user_role (str): The user role
        action_title (str): The action title
        action_description (str): The action description
        action_type (str): Type of action ('recommended', 'user_added', 'completed')
        priority_level (int): Priority level (1=high, 2=medium, 3=low)
        estimated_effort (str): Estimated effort ('low', 'medium', 'high')
        estimated_impact (str): Estimated impact ('low', 'medium', 'high')
        
    Returns:
        int: The ID of the new action
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        INSERT INTO priority_actions 
        (priority_id, grid_type, user_role, action_title, action_description, action_type, 
         priority_level, estimated_effort, estimated_impact)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (priority_id, grid_type, user_role, action_title, action_description, 
          action_type, priority_level, estimated_effort, estimated_impact))
    
    action_id = cursor.lastrowid
    conn.commit()
    conn.close()
    
    return action_id


def delete_priority_data(priority_id, user_role):
    """
    Soft delete all data for a priority (insights, notes, actions).
    
    Args:
        priority_id (str): The priority identifier
        user_role (str): The user role
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # Soft delete insights
    cursor.execute("""
        UPDATE priority_insights 
        SET is_active = 0, updated_ts = datetime('now')
        WHERE priority_id = ? AND user_role = ?
    """, (priority_id, user_role))
    
    # Soft delete notes
    cursor.execute("""
        UPDATE priority_notes 
        SET is_active = 0, updated_ts = datetime('now')
        WHERE priority_id = ? AND user_role = ?
    """, (priority_id, user_role))
    
    # Soft delete actions
    cursor.execute("""
        UPDATE priority_actions 
        SET is_active = 0, updated_ts = datetime('now')
        WHERE priority_id = ? AND user_role = ?
    """, (priority_id, user_role))
    
    conn.commit()
    conn.close()


def get_priority_summary(priority_id, grid_type, user_role):
    """
    Get a summary of all data for a priority (insights, notes, actions).
    
    Args:
        priority_id (str): The priority identifier
        grid_type (str): The grid type (short-term/long-term)
        user_role (str): The user role
        
    Returns:
        dict: Summary of all priority data
    """
    insights = get_priority_insights(priority_id, grid_type, user_role)
    notes = get_priority_notes(priority_id, grid_type, user_role)
    actions = get_priority_actions(priority_id, grid_type, user_role)
    
    return {
        "priority_id": priority_id,
        "insights": insights,
        "notes": notes,
        "actions": actions,
        "summary": {
            "has_insights": insights is not None,
            "notes_count": len(notes),
            "actions_count": len(actions),
            "last_updated": insights["updated_ts"] if insights else None
        }
    }


def save_priority_analysis(priority_id, grid_type, priority_title, priority_data, 
                          insights_content, actions_data, notes_data, user_role):
    """
    Save a complete priority analysis snapshot.
    
    Args:
        priority_id (str): The priority identifier
        grid_type (str): The grid type (short-term/long-term)
        priority_title (str): The priority title
        priority_data (str): JSON string of priority data
        insights_content (str): The insights content
        actions_data (str): JSON string of actions data
        notes_data (str): JSON string of notes data
        user_role (str): The user role
        
    Returns:
        int: The ID of the saved analysis
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # Use INSERT OR REPLACE to handle duplicates
    cursor.execute("""
        INSERT OR REPLACE INTO saved_priority_analyses 
        (priority_id, grid_type, priority_title, priority_data, insights_content, 
         actions_data, notes_data, user_role, created_ts)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
    """, (priority_id, grid_type, priority_title, priority_data, 
          insights_content, actions_data, notes_data, user_role))
    
    analysis_id = cursor.lastrowid
    conn.commit()
    conn.close()
    
    return analysis_id


def get_saved_analyses(user_role):
    """
    Get all saved priority analyses for a user role.
    
    Args:
        user_role (str): The user role
        
    Returns:
        list: List of saved analyses
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT id, priority_id, grid_type, priority_title, priority_data,
               insights_content, actions_data, notes_data, created_ts
        FROM saved_priority_analyses 
        WHERE user_role = ? AND is_active = 1
        ORDER BY created_ts DESC
    """, (user_role,))
    
    analyses = []
    for row in cursor.fetchall():
        analyses.append({
            "id": row[0],
            "priority_id": row[1],
            "grid_type": row[2],
            "priority_title": row[3],
            "priority_data": row[4],
            "insights_content": row[5],
            "actions_data": row[6],
            "notes_data": row[7],
            "created_ts": row[8]
        })
    
    conn.close()
    return analyses


def delete_saved_analysis(analysis_id, user_role):
    """
    Delete a saved priority analysis.
    
    Args:
        analysis_id (int): The analysis ID
        user_role (str): The user role for authorization
        
    Returns:
        bool: True if deleted, False if not found
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        UPDATE saved_priority_analyses 
        SET is_active = 0 
        WHERE id = ? AND user_role = ?
    """, (analysis_id, user_role))
    
    deleted_count = cursor.rowcount
    conn.commit()
    conn.close()
    
    return deleted_count > 0
